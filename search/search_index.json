{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction ko makes building Go container images easy, fast, and secure by default. ko is a simple, fast container image builder for Go applications. It's ideal for use cases where your image contains a single Go application without many dependencies on the OS base image (e.g., no cgo, no OS package dependencies). ko builds images by executing go build on your local machine, and as such doesn't require docker to be installed. This can make it a good fit for lightweight CI/CD use cases. ko also includes support for simple YAML templating which makes it a powerful tool for Kubernetes applications . \ud83c\udfc3 Install ko and get started ! ko is used and loved by these open source projects: Knative Tekton Karpenter Sigstore Shipwright Add your project here!","title":"Introduction"},{"location":"#introduction","text":"ko makes building Go container images easy, fast, and secure by default. ko is a simple, fast container image builder for Go applications. It's ideal for use cases where your image contains a single Go application without many dependencies on the OS base image (e.g., no cgo, no OS package dependencies). ko builds images by executing go build on your local machine, and as such doesn't require docker to be installed. This can make it a good fit for lightweight CI/CD use cases. ko also includes support for simple YAML templating which makes it a powerful tool for Kubernetes applications . \ud83c\udfc3 Install ko and get started ! ko is used and loved by these open source projects: Knative Tekton Karpenter Sigstore Shipwright Add your project here!","title":"Introduction"},{"location":"configuration/","text":"Configuration Basic Configuration Aside from KO_DOCKER_REPO , you can configure ko 's behavior using a .ko.yaml file. The location of this file can be overridden with KO_CONFIG_PATH . Overriding Base Images By default, ko bases images on gcr.io/distroless/static:nonroot . This is a small image that provides the bare necessities to run your Go binary. You can override this base image in two ways: To override the base image for all images ko builds, add this line to your .ko.yaml file: defaultBaseImage: registry.example.com/base/image To override the base image for certain importpaths: baseImageOverrides: github.com/my-user/my-repo/cmd/app: registry.example.com/base/for/app github.com/my-user/my-repo/cmd/foo: registry.example.com/base/for/foo Overriding Go build settings By default, ko builds the binary with no additional build flags other than -trimpath . You can replace the default build arguments by providing build flags and ldflags using a GoReleaser influenced builds configuration section in your .ko.yaml . builds: - id: foo dir: . # default is . main: ./foobar/foo env: - GOPRIVATE=git.internal.example.com,source.developers.google.com flags: - -tags - netgo ldflags: - -s -w - -extldflags \"-static\" - -X main.version={{.Env.VERSION}} - id: bar dir: ./bar main: . # default is . env: - GOCACHE=/workspace/.gocache ldflags: - -s - -w If your repository contains multiple modules (multiple go.mod files in different directories), use the dir field to specify the directory where ko should run go build . ko picks the entry from builds based on the import path you request. The import path is matched against the result of joining dir and main . The paths specified in dir and main are relative to the working directory of the ko process. The ldflags default value is [] . \ud83d\udca1 Note: Even though the configuration section is similar to the GoReleaser builds section , only the env , flags and ldflags fields are currently supported. Also, the templating support is currently limited to using environment variables only. Naming Images ko provides a few different strategies for naming the image it pushes, to workaround certain registry limitations and user preferences: Given KO_DOCKER_REPO=registry.example.com/repo , by default, ko build ./cmd/app will produce an image named like registry.example.com/repo/app-<md5> , which includes the MD5 hash of the full import path, to avoid collisions. --preserve-import-path ( -P ) will include the entire importpath: registry.example.com/repo/github.com/my-user/my-repo/cmd/app --base-import-paths ( -B ) will omit the MD5 portion: registry.example.com/repo/app --bare will only include the KO_DOCKER_REPO : registry.example.com/repo Local Publishing Options ko is normally used to publish images to container image registries, identified by KO_DOCKER_REPO . ko can also load images to a local Docker daemon, if available, by setting KO_DOCKER_REPO=ko.local , or by passing the --local ( -L ) flag. Local images can be used as a base image for other ko images: defaultBaseImage: ko.local/example/base/image ko can also load images into a local KinD cluster, if available, by setting KO_DOCKER_REPO=kind.local . By default this loads into the default KinD cluster name ( kind ). To load into another KinD cluster, set KIND_CLUSTER_NAME=my-other-cluster .","title":"Configuration"},{"location":"configuration/#configuration","text":"","title":"Configuration"},{"location":"configuration/#basic-configuration","text":"Aside from KO_DOCKER_REPO , you can configure ko 's behavior using a .ko.yaml file. The location of this file can be overridden with KO_CONFIG_PATH .","title":"Basic Configuration"},{"location":"configuration/#overriding-base-images","text":"By default, ko bases images on gcr.io/distroless/static:nonroot . This is a small image that provides the bare necessities to run your Go binary. You can override this base image in two ways: To override the base image for all images ko builds, add this line to your .ko.yaml file: defaultBaseImage: registry.example.com/base/image To override the base image for certain importpaths: baseImageOverrides: github.com/my-user/my-repo/cmd/app: registry.example.com/base/for/app github.com/my-user/my-repo/cmd/foo: registry.example.com/base/for/foo","title":"Overriding Base Images"},{"location":"configuration/#overriding-go-build-settings","text":"By default, ko builds the binary with no additional build flags other than -trimpath . You can replace the default build arguments by providing build flags and ldflags using a GoReleaser influenced builds configuration section in your .ko.yaml . builds: - id: foo dir: . # default is . main: ./foobar/foo env: - GOPRIVATE=git.internal.example.com,source.developers.google.com flags: - -tags - netgo ldflags: - -s -w - -extldflags \"-static\" - -X main.version={{.Env.VERSION}} - id: bar dir: ./bar main: . # default is . env: - GOCACHE=/workspace/.gocache ldflags: - -s - -w If your repository contains multiple modules (multiple go.mod files in different directories), use the dir field to specify the directory where ko should run go build . ko picks the entry from builds based on the import path you request. The import path is matched against the result of joining dir and main . The paths specified in dir and main are relative to the working directory of the ko process. The ldflags default value is [] . \ud83d\udca1 Note: Even though the configuration section is similar to the GoReleaser builds section , only the env , flags and ldflags fields are currently supported. Also, the templating support is currently limited to using environment variables only.","title":"Overriding Go build settings"},{"location":"configuration/#naming-images","text":"ko provides a few different strategies for naming the image it pushes, to workaround certain registry limitations and user preferences: Given KO_DOCKER_REPO=registry.example.com/repo , by default, ko build ./cmd/app will produce an image named like registry.example.com/repo/app-<md5> , which includes the MD5 hash of the full import path, to avoid collisions. --preserve-import-path ( -P ) will include the entire importpath: registry.example.com/repo/github.com/my-user/my-repo/cmd/app --base-import-paths ( -B ) will omit the MD5 portion: registry.example.com/repo/app --bare will only include the KO_DOCKER_REPO : registry.example.com/repo","title":"Naming Images"},{"location":"configuration/#local-publishing-options","text":"ko is normally used to publish images to container image registries, identified by KO_DOCKER_REPO . ko can also load images to a local Docker daemon, if available, by setting KO_DOCKER_REPO=ko.local , or by passing the --local ( -L ) flag. Local images can be used as a base image for other ko images: defaultBaseImage: ko.local/example/base/image ko can also load images into a local KinD cluster, if available, by setting KO_DOCKER_REPO=kind.local . By default this loads into the default KinD cluster name ( kind ). To load into another KinD cluster, set KIND_CLUSTER_NAME=my-other-cluster .","title":"Local Publishing Options"},{"location":"deployment/","text":"Deployment See Kubernetes Integration for information about deploying to Kubernetes. Because the output of ko build is an image reference, you can easily pass it to other tools that expect to take an image reference. docker run To run the container locally: docker run -p 8080:8080 $(ko build ./cmd/app) Google Cloud Run gcloud run deploy --image=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to Google Container Registry or Artifact Registry . fly.io flyctl launch --image=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be publicly available. AWS Lambda aws lambda update-function-code \\ --function-name=my-function-name \\ --image-uri=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to ECR , based on the AWS provided base image, and use the aws-lambda-go framework. See official docs for more information. Azure Container Apps az containerapp update \\ --name my-container-app --resource-group my-resource-group --image $(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to ACR or other registry service. See official docs for more information.","title":"Deployment"},{"location":"deployment/#deployment","text":"See Kubernetes Integration for information about deploying to Kubernetes. Because the output of ko build is an image reference, you can easily pass it to other tools that expect to take an image reference.","title":"Deployment"},{"location":"deployment/#docker-run","text":"To run the container locally: docker run -p 8080:8080 $(ko build ./cmd/app)","title":"docker run"},{"location":"deployment/#google-cloud-run","text":"gcloud run deploy --image=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to Google Container Registry or Artifact Registry .","title":"Google Cloud Run"},{"location":"deployment/#flyio","text":"flyctl launch --image=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be publicly available.","title":"fly.io"},{"location":"deployment/#aws-lambda","text":"aws lambda update-function-code \\ --function-name=my-function-name \\ --image-uri=$(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to ECR , based on the AWS provided base image, and use the aws-lambda-go framework. See official docs for more information.","title":"AWS Lambda"},{"location":"deployment/#azure-container-apps","text":"az containerapp update \\ --name my-container-app --resource-group my-resource-group --image $(ko build ./cmd/app) \ud83d\udca1 Note: The image must be pushed to ACR or other registry service. See official docs for more information.","title":"Azure Container Apps"},{"location":"get-started/","text":"Get Started Setup First, install ko Authenticate ko depends on the authentication configured in your Docker config (typically ~/.docker/config.json ). \u2728 If you can push an image with docker push , you are already authenticated for ko ! \u2728 Since ko doesn't require docker , ko login also provides a surface for logging in to a container image registry with a username and password, similar to docker login . Additionally, even if auth is not configured in the Docker config, ko includes built-in support for authenticating to the following container registries using credentials configured in the environment: Google Container Registry and Artifact Registry, using Application Default Credentials or auth configured in gcloud . Amazon Elastic Container Registry, using AWS credentials Azure Container Registry, using environment variables GitHub Container Registry, using the GITHUB_TOKEN environment variable Choose Destination ko depends on an environment variable, KO_DOCKER_REPO , to identify where it should push images that it builds. Typically this will be a remote registry, e.g.: KO_DOCKER_REPO=gcr.io/my-project , or KO_DOCKER_REPO=ghcr.io/my-org/my-repo , or KO_DOCKER_REPO=my-dockerhub-user Build an Image ko build ./cmd/app builds and pushes a container image, and prints the resulting image digest to stdout. In this example, ./cmd/app must be a package main that defines func main() . $ ko build ./cmd/app ... registry.example.com/my-project/app-099ba5bcefdead87f92606265fb99ac0@sha256:6e398316742b7aa4a93161dce4a23bc5c545700b862b43347b941000b112ec3e \ud83d\udca1 Note : Prior to v0.10, the command was called ko publish -- this is equivalent to ko build , and both commands will work and do the same thing. The executable binary that was built from ./cmd/app is available in the image at /ko-app/app -- the binary name matches the base import path name -- and that binary is the image's entrypoint.","title":"Get Started"},{"location":"get-started/#get-started","text":"","title":"Get Started"},{"location":"get-started/#setup","text":"First, install ko","title":"Setup"},{"location":"get-started/#authenticate","text":"ko depends on the authentication configured in your Docker config (typically ~/.docker/config.json ). \u2728 If you can push an image with docker push , you are already authenticated for ko ! \u2728 Since ko doesn't require docker , ko login also provides a surface for logging in to a container image registry with a username and password, similar to docker login . Additionally, even if auth is not configured in the Docker config, ko includes built-in support for authenticating to the following container registries using credentials configured in the environment: Google Container Registry and Artifact Registry, using Application Default Credentials or auth configured in gcloud . Amazon Elastic Container Registry, using AWS credentials Azure Container Registry, using environment variables GitHub Container Registry, using the GITHUB_TOKEN environment variable","title":"Authenticate"},{"location":"get-started/#choose-destination","text":"ko depends on an environment variable, KO_DOCKER_REPO , to identify where it should push images that it builds. Typically this will be a remote registry, e.g.: KO_DOCKER_REPO=gcr.io/my-project , or KO_DOCKER_REPO=ghcr.io/my-org/my-repo , or KO_DOCKER_REPO=my-dockerhub-user","title":"Choose Destination"},{"location":"get-started/#build-an-image","text":"ko build ./cmd/app builds and pushes a container image, and prints the resulting image digest to stdout. In this example, ./cmd/app must be a package main that defines func main() . $ ko build ./cmd/app ... registry.example.com/my-project/app-099ba5bcefdead87f92606265fb99ac0@sha256:6e398316742b7aa4a93161dce4a23bc5c545700b862b43347b941000b112ec3e \ud83d\udca1 Note : Prior to v0.10, the command was called ko publish -- this is equivalent to ko build , and both commands will work and do the same thing. The executable binary that was built from ./cmd/app is available in the image at /ko-app/app -- the binary name matches the base import path name -- and that binary is the image's entrypoint.","title":"Build an Image"},{"location":"install/","text":"Installation Install from GitHub Releases VERSION=TODO # choose the latest version OS=Linux # or Darwin, Windows ARCH=x86_64 # or arm64, i386, s390x curl -L https://github.com/google/ko/releases/download/v${VERSION}/ko_${VERSION}_${OS}_${ARCH}.tar.gz | tar xzf - ko chmod +x ./ko Install using Homebrew brew install ko Build and Install from source With Go 1.16+, build and install the latest released version: go install github.com/google/ko@latest Setup on GitHub Actions You can use the setup-ko action to install ko and setup auth to GitHub Container Registry in a GitHub Action workflow: steps: - uses: imjasonh/setup-ko@v0.4","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#install-from-github-releases","text":"VERSION=TODO # choose the latest version OS=Linux # or Darwin, Windows ARCH=x86_64 # or arm64, i386, s390x curl -L https://github.com/google/ko/releases/download/v${VERSION}/ko_${VERSION}_${OS}_${ARCH}.tar.gz | tar xzf - ko chmod +x ./ko","title":"Install from GitHub Releases"},{"location":"install/#install-using-homebrew","text":"brew install ko","title":"Install using Homebrew"},{"location":"install/#build-and-install-from-source","text":"With Go 1.16+, build and install the latest released version: go install github.com/google/ko@latest","title":"Build and Install from source"},{"location":"install/#setup-on-github-actions","text":"You can use the setup-ko action to install ko and setup auth to GitHub Container Registry in a GitHub Action workflow: steps: - uses: imjasonh/setup-ko@v0.4","title":"Setup on GitHub Actions"},{"location":"advanced/faq/","text":"Frequently Asked Questions How can I set ldflags ? Using -ldflags is a common way to embed version info in go binaries (In fact, we do this for ko !). Unfortunately, because ko wraps go build , it's not possible to use this flag directly; however, you can use the GOFLAGS environment variable instead: GOFLAGS=\"-ldflags=-X=main.version=1.2.3\" ko build . Currently, there is a limitation that does not allow to set multiple arguments in ldflags using GOFLAGS . Using -ldflags multiple times also does not work. In this use case, it works best to use the builds section in the .ko.yaml file. Why are my images all created in 1970? In order to support reproducible builds , ko doesn't embed timestamps in the images it produces by default. However, ko does respect the SOURCE_DATE_EPOCH environment variable, which will set the container image's timestamp accordingly. Similarly, the KO_DATA_DATE_EPOCH environment variable can be used to set the modtime timestamp of the files in KO_DATA_PATH . For example, you can set the container image's timestamp to the current timestamp by executing: export SOURCE_DATE_EPOCH=$(date +%s) or set the timestamp of the files in KO_DATA_PATH to the latest git commit's timestamp with: export KO_DATA_DATE_EPOCH=$(git log -1 --format='%ct') Can I build Windows containers? Yes, but support for Windows containers is new, experimental, and tenuous. Be prepared to file bugs. \ud83d\udc1b The default base image does not provide a Windows image. You can try out building a Windows container image by setting the base image to a Windows base image and building with --platform=windows/amd64 or --platform=all : For example, to build a Windows container image, update your .ko.yaml to set the base image: defaultBaseImage: mcr.microsoft.com/windows/nanoserver:ltsc2022 And build for windows/amd64 . ko build ./ --platform=windows/amd64 Known issues \ud83d\udc1b Symlinks in kodata are ignored when building Windows images; only regular files and directories will be included in the Windows image. Can I optimize images for eStargz support ? Yes! Set the environment variable GGCR_EXPERIMENT_ESTARGZ=1 to produce eStargz-optimized images. Does ko support autocompletion? Yes! ko completion generates a Bash/Zsh/Fish/PowerShell completion script. You can get how to load it from help document. ko completion [bash|zsh|fish|powershell] --help Or, you can source it directly: source <(ko completion) Does ko work with Kustomize ? Yes! ko resolve -f - will read and process input from stdin, so you can have ko easily process the output of the kustomize command. kustomize build config | ko resolve -f - Does ko integrate with other build and development tools? Oh, you betcha. Here's a partial list: ko support in Carvel's kbld ko support in Skaffold ko extension for Tilt ko support for goreleaser (proposed) Does ko work with OpenShift Internal Registry ? Yes! Follow these steps: Connect to your OpenShift installation Expose the OpenShift Internal Registry so you can push to it: Export your token to $HOME/.docker/config.json : oc registry login --to=$HOME/.docker/config.json Create a namespace where you will push your images, i.e: ko-images Execute this command to set KO_DOCKER_REPO to publish images to the internal registry. export KO_DOCKER_REPO=$(oc registry info --public)/ko-images","title":"Frequently Asked Questions"},{"location":"advanced/faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"advanced/faq/#how-can-i-set-ldflags","text":"Using -ldflags is a common way to embed version info in go binaries (In fact, we do this for ko !). Unfortunately, because ko wraps go build , it's not possible to use this flag directly; however, you can use the GOFLAGS environment variable instead: GOFLAGS=\"-ldflags=-X=main.version=1.2.3\" ko build . Currently, there is a limitation that does not allow to set multiple arguments in ldflags using GOFLAGS . Using -ldflags multiple times also does not work. In this use case, it works best to use the builds section in the .ko.yaml file.","title":"How can I set ldflags?"},{"location":"advanced/faq/#why-are-my-images-all-created-in-1970","text":"In order to support reproducible builds , ko doesn't embed timestamps in the images it produces by default. However, ko does respect the SOURCE_DATE_EPOCH environment variable, which will set the container image's timestamp accordingly. Similarly, the KO_DATA_DATE_EPOCH environment variable can be used to set the modtime timestamp of the files in KO_DATA_PATH . For example, you can set the container image's timestamp to the current timestamp by executing: export SOURCE_DATE_EPOCH=$(date +%s) or set the timestamp of the files in KO_DATA_PATH to the latest git commit's timestamp with: export KO_DATA_DATE_EPOCH=$(git log -1 --format='%ct')","title":"Why are my images all created in 1970?"},{"location":"advanced/faq/#can-i-build-windows-containers","text":"Yes, but support for Windows containers is new, experimental, and tenuous. Be prepared to file bugs. \ud83d\udc1b The default base image does not provide a Windows image. You can try out building a Windows container image by setting the base image to a Windows base image and building with --platform=windows/amd64 or --platform=all : For example, to build a Windows container image, update your .ko.yaml to set the base image: defaultBaseImage: mcr.microsoft.com/windows/nanoserver:ltsc2022 And build for windows/amd64 . ko build ./ --platform=windows/amd64","title":"Can I build Windows containers?"},{"location":"advanced/faq/#known-issues","text":"Symlinks in kodata are ignored when building Windows images; only regular files and directories will be included in the Windows image.","title":"Known issues \ud83d\udc1b"},{"location":"advanced/faq/#can-i-optimize-images-for-estargz-support","text":"Yes! Set the environment variable GGCR_EXPERIMENT_ESTARGZ=1 to produce eStargz-optimized images.","title":"Can I optimize images for eStargz support?"},{"location":"advanced/faq/#does-ko-support-autocompletion","text":"Yes! ko completion generates a Bash/Zsh/Fish/PowerShell completion script. You can get how to load it from help document. ko completion [bash|zsh|fish|powershell] --help Or, you can source it directly: source <(ko completion)","title":"Does ko support autocompletion?"},{"location":"advanced/faq/#does-ko-work-with-kustomize","text":"Yes! ko resolve -f - will read and process input from stdin, so you can have ko easily process the output of the kustomize command. kustomize build config | ko resolve -f -","title":"Does ko work with Kustomize?"},{"location":"advanced/faq/#does-ko-integrate-with-other-build-and-development-tools","text":"Oh, you betcha. Here's a partial list: ko support in Carvel's kbld ko support in Skaffold ko extension for Tilt ko support for goreleaser (proposed)","title":"Does ko integrate with other build and development tools?"},{"location":"advanced/faq/#does-ko-work-with-openshift-internal-registry","text":"Yes! Follow these steps: Connect to your OpenShift installation Expose the OpenShift Internal Registry so you can push to it: Export your token to $HOME/.docker/config.json : oc registry login --to=$HOME/.docker/config.json Create a namespace where you will push your images, i.e: ko-images Execute this command to set KO_DOCKER_REPO to publish images to the internal registry. export KO_DOCKER_REPO=$(oc registry info --public)/ko-images","title":"Does ko work with OpenShift Internal Registry?"},{"location":"advanced/go-packages/","text":"Go Packages ko 's functionality can be consumed as a library in a Go application. To build an image, use pkg/build , and publish it with pkg/publish .","title":"Go Packages"},{"location":"advanced/go-packages/#go-packages","text":"ko 's functionality can be consumed as a library in a Go application. To build an image, use pkg/build , and publish it with pkg/publish .","title":"Go Packages"},{"location":"advanced/limitations/","text":"Limitations ko works best when your application has no dependencies on the underlying image. This means ko is ideal when you don't require cgo , and builds are executed with CGO_ENABLED=0 by default. To install other OS packages, make those available in your configured base image . ko only supports Go applications. For a similar tool targeting Java applications, try Jib . For other languages, try apko and melange .","title":"Limitations"},{"location":"advanced/limitations/#limitations","text":"ko works best when your application has no dependencies on the underlying image. This means ko is ideal when you don't require cgo , and builds are executed with CGO_ENABLED=0 by default. To install other OS packages, make those available in your configured base image . ko only supports Go applications. For a similar tool targeting Java applications, try Jib . For other languages, try apko and melange .","title":"Limitations"},{"location":"advanced/migrating-from-dockerfile/","text":"Migrating from Dockerfile If your Dockerfile looks like either of the examples in the official tutorial for writing a Dockerfile to containerize a Go application , you can easily migrate to use ko instead. Let's review the best practice multi-stage Dockerfile in that tutorial first: # syntax=docker/dockerfile:1 ## ## Build ## FROM golang:1.16-buster AS build WORKDIR /app COPY go.mod ./ COPY go.sum ./ RUN go mod download COPY *.go ./ RUN go build -o /docker-gs-ping ## ## Deploy ## FROM gcr.io/distroless/base-debian10 WORKDIR / COPY --from=build /docker-gs-ping /docker-gs-ping EXPOSE 8080 USER nonroot:nonroot ENTRYPOINT [\"/docker-gs-ping\"] This Dockerfile : pulls the golang:1.16 image COPY s your local source into the container environment ( COPY ing go.mod and go.sum first and running go mod download , to cache dependencies in the container environment) RUN s go build on your source, inside the container, to produce an executable COPY s the executable built in the previous step into a new image, on top of a minimal distroless base image. The result is a Go application built on a minimal base image, with an optimally cached build sequence. After running docker build on this Dockerfile , don't forget to push that image to the registry so you can deploy it. Migrating to ko If your Go source is laid out as described in the tutorial, and you've installed and set up your environment , you can simply run ko build ./ to build and push the container image to your registry. You're done. You can delete your Dockerfile and uninstall docker . ko takes advantage of your local Go build cache without needing to be told to, and it sets the ENTRYPOINT and uses a nonroot distroless base image by default. To build a multi-arch image, simply add --platform=all . Compare this to the equivalent Docker instructions .","title":"Migrating from Dockerfile"},{"location":"advanced/migrating-from-dockerfile/#migrating-from-dockerfile","text":"If your Dockerfile looks like either of the examples in the official tutorial for writing a Dockerfile to containerize a Go application , you can easily migrate to use ko instead. Let's review the best practice multi-stage Dockerfile in that tutorial first: # syntax=docker/dockerfile:1 ## ## Build ## FROM golang:1.16-buster AS build WORKDIR /app COPY go.mod ./ COPY go.sum ./ RUN go mod download COPY *.go ./ RUN go build -o /docker-gs-ping ## ## Deploy ## FROM gcr.io/distroless/base-debian10 WORKDIR / COPY --from=build /docker-gs-ping /docker-gs-ping EXPOSE 8080 USER nonroot:nonroot ENTRYPOINT [\"/docker-gs-ping\"] This Dockerfile : pulls the golang:1.16 image COPY s your local source into the container environment ( COPY ing go.mod and go.sum first and running go mod download , to cache dependencies in the container environment) RUN s go build on your source, inside the container, to produce an executable COPY s the executable built in the previous step into a new image, on top of a minimal distroless base image. The result is a Go application built on a minimal base image, with an optimally cached build sequence. After running docker build on this Dockerfile , don't forget to push that image to the registry so you can deploy it.","title":"Migrating from Dockerfile"},{"location":"advanced/migrating-from-dockerfile/#migrating-to-ko","text":"If your Go source is laid out as described in the tutorial, and you've installed and set up your environment , you can simply run ko build ./ to build and push the container image to your registry. You're done. You can delete your Dockerfile and uninstall docker . ko takes advantage of your local Go build cache without needing to be told to, and it sets the ENTRYPOINT and uses a nonroot distroless base image by default. To build a multi-arch image, simply add --platform=all . Compare this to the equivalent Docker instructions .","title":"Migrating to ko"},{"location":"features/build-cache/","text":"Build Cache Because ko just runs go build in your normal development environment, it automatically reuses your go build cache from previous builds, making iterative development faster. ko also avoids pushing blobs to the remote image registry if they're already present, making pushes faster. You can make ko even faster by setting the KOCACHE environment variable. This tells ko to store a local mapping between the go build inputs to the image layer that they produce, so go build can be skipped entirely if the layer is already present in the image registry.","title":"Build Cache"},{"location":"features/build-cache/#build-cache","text":"Because ko just runs go build in your normal development environment, it automatically reuses your go build cache from previous builds, making iterative development faster. ko also avoids pushing blobs to the remote image registry if they're already present, making pushes faster. You can make ko even faster by setting the KOCACHE environment variable. This tells ko to store a local mapping between the go build inputs to the image layer that they produce, so go build can be skipped entirely if the layer is already present in the image registry.","title":"Build Cache"},{"location":"features/k8s/","text":"Kubernetes Integration You could stop at just building and pushing images. But, because building images is so easy with ko , and because building with ko only requires a string importpath to identify the image, we can integrate this with YAML generation to make Kubernetes use cases much simpler. YAML Changes Traditionally, you might have a Kubernetes deployment, defined in a YAML file, that runs an image: apiVersion: apps/v1 kind: Deployment metadata: name: my-deployment spec: replicas: 3 ... template: spec: containers: - name: my-app image: registry.example.com/my-app:v1.2.3 ...which you apply to your cluster with kubectl apply : kubectl apply -f deployment.yaml With ko , you can instead reference your Go binary by its importpath, prefixed with ko:// : ... spec: containers: - name: my-app image: ko://github.com/my-user/my-repo/cmd/app ko resolve With this small change, running ko resolve -f deployment.yaml will instruct ko to: scan the YAML file(s) for values with the ko:// prefix, for each unique ko:// -prefixed string, execute ko build <importpath> to build and push an image, replace ko:// -prefixed string(s) in the input YAML with the fully-specified image reference of the built image(s), as above. Print the resulting resolved YAML to stdout. The result can be redirected to a file, to distribute to others: ko resolve -f config/ > release.yaml Taken together, ko resolve aims to make packaging, pushing, and referencing container images an invisible implementation detail of your Kubernetes deployment, and let you focus on writing code in Go. ko apply To apply the resulting resolved YAML config, you can redirect the output of ko resolve to kubectl apply : ko resolve -f config/ | kubectl apply -f - Since this is a relatively common use case, the same functionality is available using ko apply : ko apply -f config/ NB: This requires that kubectl is available. ko delete To teardown resources applied using ko apply , you can run ko delete : ko delete -f config/ This is purely a convenient alias for kubectl delete , and doesn't perform any builds, or delete any previously built images.","title":"Kubernetes Integration"},{"location":"features/k8s/#kubernetes-integration","text":"You could stop at just building and pushing images. But, because building images is so easy with ko , and because building with ko only requires a string importpath to identify the image, we can integrate this with YAML generation to make Kubernetes use cases much simpler.","title":"Kubernetes Integration"},{"location":"features/k8s/#yaml-changes","text":"Traditionally, you might have a Kubernetes deployment, defined in a YAML file, that runs an image: apiVersion: apps/v1 kind: Deployment metadata: name: my-deployment spec: replicas: 3 ... template: spec: containers: - name: my-app image: registry.example.com/my-app:v1.2.3 ...which you apply to your cluster with kubectl apply : kubectl apply -f deployment.yaml With ko , you can instead reference your Go binary by its importpath, prefixed with ko:// : ... spec: containers: - name: my-app image: ko://github.com/my-user/my-repo/cmd/app","title":"YAML Changes"},{"location":"features/k8s/#ko-resolve","text":"With this small change, running ko resolve -f deployment.yaml will instruct ko to: scan the YAML file(s) for values with the ko:// prefix, for each unique ko:// -prefixed string, execute ko build <importpath> to build and push an image, replace ko:// -prefixed string(s) in the input YAML with the fully-specified image reference of the built image(s), as above. Print the resulting resolved YAML to stdout. The result can be redirected to a file, to distribute to others: ko resolve -f config/ > release.yaml Taken together, ko resolve aims to make packaging, pushing, and referencing container images an invisible implementation detail of your Kubernetes deployment, and let you focus on writing code in Go.","title":"ko resolve"},{"location":"features/k8s/#ko-apply","text":"To apply the resulting resolved YAML config, you can redirect the output of ko resolve to kubectl apply : ko resolve -f config/ | kubectl apply -f - Since this is a relatively common use case, the same functionality is available using ko apply : ko apply -f config/ NB: This requires that kubectl is available.","title":"ko apply"},{"location":"features/k8s/#ko-delete","text":"To teardown resources applied using ko apply , you can run ko delete : ko delete -f config/ This is purely a convenient alias for kubectl delete , and doesn't perform any builds, or delete any previously built images.","title":"ko delete"},{"location":"features/multi-platform/","text":"Multi-Platform Images Because Go supports cross-compilation to other CPU architectures and operating systems, ko excels at producing multi-platform images. To build and push an image for all platforms supported by the configured base image, simply add --platform=all . This will instruct ko to look up all the supported platforms in the base image, execute GOOS=<os> GOARCH=<arch> GOARM=<variant> go build for each platform, and produce a manifest list containing an image for each platform. You can also select specific platforms, for example, --platform=linux/amd64,linux/arm64 . ko also has experimental support for building for Windows images. See FAQ .","title":"Multi-Platform Images"},{"location":"features/multi-platform/#multi-platform-images","text":"Because Go supports cross-compilation to other CPU architectures and operating systems, ko excels at producing multi-platform images. To build and push an image for all platforms supported by the configured base image, simply add --platform=all . This will instruct ko to look up all the supported platforms in the base image, execute GOOS=<os> GOARCH=<arch> GOARM=<variant> go build for each platform, and produce a manifest list containing an image for each platform. You can also select specific platforms, for example, --platform=linux/amd64,linux/arm64 . ko also has experimental support for building for Windows images. See FAQ .","title":"Multi-Platform Images"},{"location":"features/sboms/","text":"SBOMs A Software Bill of Materials (SBOM) is a list of software components that a software artifact depends on. Having a list of dependencies can be helpful in determining whether any vulnerable components were used to build the software artifact. From v0.9+, ko generates and uploads an SBOM for every image it produces by default. ko will generate an SBOM in the SPDX format by default, but you can select the CycloneDX format instead with the --sbom=cyclonedx flag. To disable SBOM generation, pass --sbom=none . These SBOMs can be downloaded using the cosign download sbom command.","title":"SBOMs"},{"location":"features/sboms/#sboms","text":"A Software Bill of Materials (SBOM) is a list of software components that a software artifact depends on. Having a list of dependencies can be helpful in determining whether any vulnerable components were used to build the software artifact. From v0.9+, ko generates and uploads an SBOM for every image it produces by default. ko will generate an SBOM in the SPDX format by default, but you can select the CycloneDX format instead with the --sbom=cyclonedx flag. To disable SBOM generation, pass --sbom=none . These SBOMs can be downloaded using the cosign download sbom command.","title":"SBOMs"},{"location":"features/static-assets/","text":"Static Assets ko can also bundle static assets into the images it produces. By convention, any contents of a directory named <importpath>/kodata/ will be bundled into the image, and the path where it's available in the image will be identified by the environment variable KO_DATA_PATH . As an example, you can bundle and serve static contents in your image: cmd/ app/ main.go kodata/ favicon.ico index.html Then, in your main.go : func main() { http.Handle(\"/\", http.FileServer(http.Dir(os.Getenv(\"KO_DATA_PATH\")))) log.Fatal(http.ListenAndServe(\":8080\", nil)) } You can simulate ko 's behavior outside of the container image by setting the KO_DATA_PATH environment variable yourself with KO_DATA_PATH=cmd/app/kodata/ go run ./cmd/app . \ud83d\udca1 Tip: Symlinks in kodata are followed and included as well. For example, you can include Git commit information in your image with ln -s -r .git/HEAD ./cmd/app/kodata/ Also note that http.FileServer will not serve the Last-Modified header (or validate If-Modified-Since request headers) because ko does not embed timestamps by default. This can be supported by manually setting the KO_DATA_DATE_EPOCH environment variable during build ( See FAQ ).","title":"Static Assets"},{"location":"features/static-assets/#static-assets","text":"ko can also bundle static assets into the images it produces. By convention, any contents of a directory named <importpath>/kodata/ will be bundled into the image, and the path where it's available in the image will be identified by the environment variable KO_DATA_PATH . As an example, you can bundle and serve static contents in your image: cmd/ app/ main.go kodata/ favicon.ico index.html Then, in your main.go : func main() { http.Handle(\"/\", http.FileServer(http.Dir(os.Getenv(\"KO_DATA_PATH\")))) log.Fatal(http.ListenAndServe(\":8080\", nil)) } You can simulate ko 's behavior outside of the container image by setting the KO_DATA_PATH environment variable yourself with KO_DATA_PATH=cmd/app/kodata/ go run ./cmd/app . \ud83d\udca1 Tip: Symlinks in kodata are followed and included as well. For example, you can include Git commit information in your image with ln -s -r .git/HEAD ./cmd/app/kodata/ Also note that http.FileServer will not serve the Last-Modified header (or validate If-Modified-Since request headers) because ko does not embed timestamps by default. This can be supported by manually setting the KO_DATA_DATE_EPOCH environment variable during build ( See FAQ ).","title":"Static Assets"},{"location":"reference/ko/","text":"ko Rapidly iterate with Go, Containers, and Kubernetes. ko [flags] Options -h, --help help for ko -v, --verbose Enable debug logs SEE ALSO ko apply - Apply the input files with image references resolved to built/pushed image digests. ko build - Build and publish container images from the given importpaths. ko create - Create the input files with image references resolved to built/pushed image digests. ko delete - See \"kubectl help delete\" for detailed usage. ko deps - Print Go module dependency information about the ko-built binary in the image ko login - Log in to a registry ko resolve - Print the input files with image references resolved to built/pushed image digests. ko run - A variant of kubectl run that containerizes IMPORTPATH first. ko version - Print ko version.","title":"ko"},{"location":"reference/ko/#ko","text":"Rapidly iterate with Go, Containers, and Kubernetes. ko [flags]","title":"ko"},{"location":"reference/ko/#options","text":"-h, --help help for ko -v, --verbose Enable debug logs","title":"Options"},{"location":"reference/ko/#see-also","text":"ko apply - Apply the input files with image references resolved to built/pushed image digests. ko build - Build and publish container images from the given importpaths. ko create - Create the input files with image references resolved to built/pushed image digests. ko delete - See \"kubectl help delete\" for detailed usage. ko deps - Print Go module dependency information about the ko-built binary in the image ko login - Log in to a registry ko resolve - Print the input files with image references resolved to built/pushed image digests. ko run - A variant of kubectl run that containerizes IMPORTPATH first. ko version - Print ko version.","title":"SEE ALSO"},{"location":"reference/ko_apply/","text":"ko apply Apply the input files with image references resolved to built/pushed image digests. Synopsis This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl apply\". ko apply -f FILENAME [flags] Examples # Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # Then, feed the resulting yaml into \"kubectl apply\". # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko apply -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # Then, feed the resulting yaml into \"kubectl apply\". ko apply --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # Then, feed the resulting yaml into \"kubectl apply\". ko apply --local -f config/ # Apply from stdin: cat config.yaml | ko apply -f - # Any flags passed after '--' are passed to 'kubectl apply' directly: ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml Options --as string Username to impersonate for the operation (DEPRECATED) --as-group stringArray Group to impersonate for the operation, this flag can be repeated to specify multiple groups. (DEPRECATED) --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --cache-dir string Default cache directory (DEPRECATED) --certificate-authority string Path to a cert file for the certificate authority (DEPRECATED) --client-certificate string Path to a client certificate file for TLS (DEPRECATED) --client-key string Path to a client key file for TLS (DEPRECATED) --cluster string The name of the kubeconfig cluster to use (DEPRECATED) --context string The name of the kubeconfig context to use (DEPRECATED) --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for apply --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry --insecure-skip-tls-verify If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure (DEPRECATED) -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) --kubeconfig string Path to the kubeconfig file to use for CLI requests. (DEPRECATED) -L, --local Load into images to local docker daemon. -n, --namespace string If present, the namespace scope for this CLI request (DEPRECATED) --oci-layout-path string Path to save the OCI image layout of the built images --password string Password for basic authentication to the API server (DEPRECATED) --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --request-timeout string The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (DEPRECATED) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) -s, --server string The address and port of the Kubernetes API server (DEPRECATED) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs --tls-server-name string Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used (DEPRECATED) --token string Bearer token for authentication to the API server (DEPRECATED) --user string The name of the kubeconfig user to use (DEPRECATED) --username string Username for basic authentication to the API server (DEPRECATED) Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko apply"},{"location":"reference/ko_apply/#ko-apply","text":"Apply the input files with image references resolved to built/pushed image digests.","title":"ko apply"},{"location":"reference/ko_apply/#synopsis","text":"This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl apply\". ko apply -f FILENAME [flags]","title":"Synopsis"},{"location":"reference/ko_apply/#examples","text":"# Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # Then, feed the resulting yaml into \"kubectl apply\". # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko apply -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # Then, feed the resulting yaml into \"kubectl apply\". ko apply --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # Then, feed the resulting yaml into \"kubectl apply\". ko apply --local -f config/ # Apply from stdin: cat config.yaml | ko apply -f - # Any flags passed after '--' are passed to 'kubectl apply' directly: ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml","title":"Examples"},{"location":"reference/ko_apply/#options","text":"--as string Username to impersonate for the operation (DEPRECATED) --as-group stringArray Group to impersonate for the operation, this flag can be repeated to specify multiple groups. (DEPRECATED) --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --cache-dir string Default cache directory (DEPRECATED) --certificate-authority string Path to a cert file for the certificate authority (DEPRECATED) --client-certificate string Path to a client certificate file for TLS (DEPRECATED) --client-key string Path to a client key file for TLS (DEPRECATED) --cluster string The name of the kubeconfig cluster to use (DEPRECATED) --context string The name of the kubeconfig context to use (DEPRECATED) --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for apply --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry --insecure-skip-tls-verify If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure (DEPRECATED) -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) --kubeconfig string Path to the kubeconfig file to use for CLI requests. (DEPRECATED) -L, --local Load into images to local docker daemon. -n, --namespace string If present, the namespace scope for this CLI request (DEPRECATED) --oci-layout-path string Path to save the OCI image layout of the built images --password string Password for basic authentication to the API server (DEPRECATED) --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --request-timeout string The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (DEPRECATED) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) -s, --server string The address and port of the Kubernetes API server (DEPRECATED) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs --tls-server-name string Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used (DEPRECATED) --token string Bearer token for authentication to the API server (DEPRECATED) --user string The name of the kubeconfig user to use (DEPRECATED) --username string Username for basic authentication to the API server (DEPRECATED)","title":"Options"},{"location":"reference/ko_apply/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_apply/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_build/","text":"ko build Build and publish container images from the given importpaths. Synopsis This sub-command builds the provided import paths into Go binaries, containerizes them, and publishes them. ko build IMPORTPATH... [flags] Examples # Build and publish import path references to a Docker Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local and # --preserve-import-paths were passed. # If the import path is not provided, the current working directory is the # default. ko build github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah # Build and publish a relative import path as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local and # --preserve-import-paths were passed. ko build ./cmd/blah # Build and publish a relative import path as: # ${KO_DOCKER_REPO}/<import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local was passed. ko build --preserve-import-paths ./cmd/blah # Build and publish import path references to a Docker daemon as: # ko.local/<import path> # This always preserves import paths. ko build --local github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah Options --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -h, --help help for build --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko build"},{"location":"reference/ko_build/#ko-build","text":"Build and publish container images from the given importpaths.","title":"ko build"},{"location":"reference/ko_build/#synopsis","text":"This sub-command builds the provided import paths into Go binaries, containerizes them, and publishes them. ko build IMPORTPATH... [flags]","title":"Synopsis"},{"location":"reference/ko_build/#examples","text":"# Build and publish import path references to a Docker Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local and # --preserve-import-paths were passed. # If the import path is not provided, the current working directory is the # default. ko build github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah # Build and publish a relative import path as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local and # --preserve-import-paths were passed. ko build ./cmd/blah # Build and publish a relative import path as: # ${KO_DOCKER_REPO}/<import path> # When KO_DOCKER_REPO is ko.local, it is the same as if --local was passed. ko build --preserve-import-paths ./cmd/blah # Build and publish import path references to a Docker daemon as: # ko.local/<import path> # This always preserves import paths. ko build --local github.com/foo/bar/cmd/baz github.com/foo/bar/cmd/blah","title":"Examples"},{"location":"reference/ko_build/#options","text":"--bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -h, --help help for build --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs","title":"Options"},{"location":"reference/ko_build/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_build/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_create/","text":"ko create Create the input files with image references resolved to built/pushed image digests. Synopsis This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl create\". ko create -f FILENAME [flags] Examples # Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # Then, feed the resulting yaml into \"kubectl create\". # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko create -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # Then, feed the resulting yaml into \"kubectl create\". ko create --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # Then, feed the resulting yaml into \"kubectl create\". ko create --local -f config/ # Create from stdin: cat config.yaml | ko create -f - # Any flags passed after '--' are passed to 'kubectl apply' directly: ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml Options --as string Username to impersonate for the operation (DEPRECATED) --as-group stringArray Group to impersonate for the operation, this flag can be repeated to specify multiple groups. (DEPRECATED) --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --cache-dir string Default cache directory (DEPRECATED) --certificate-authority string Path to a cert file for the certificate authority (DEPRECATED) --client-certificate string Path to a client certificate file for TLS (DEPRECATED) --client-key string Path to a client key file for TLS (DEPRECATED) --cluster string The name of the kubeconfig cluster to use (DEPRECATED) --context string The name of the kubeconfig context to use (DEPRECATED) --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for create --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry --insecure-skip-tls-verify If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure (DEPRECATED) -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) --kubeconfig string Path to the kubeconfig file to use for CLI requests. (DEPRECATED) -L, --local Load into images to local docker daemon. -n, --namespace string If present, the namespace scope for this CLI request (DEPRECATED) --oci-layout-path string Path to save the OCI image layout of the built images --password string Password for basic authentication to the API server (DEPRECATED) --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --request-timeout string The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (DEPRECATED) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) -s, --server string The address and port of the Kubernetes API server (DEPRECATED) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs --tls-server-name string Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used (DEPRECATED) --token string Bearer token for authentication to the API server (DEPRECATED) --user string The name of the kubeconfig user to use (DEPRECATED) --username string Username for basic authentication to the API server (DEPRECATED) Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko create"},{"location":"reference/ko_create/#ko-create","text":"Create the input files with image references resolved to built/pushed image digests.","title":"ko create"},{"location":"reference/ko_create/#synopsis","text":"This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and then feeds the resulting yaml into \"kubectl create\". ko create -f FILENAME [flags]","title":"Synopsis"},{"location":"reference/ko_create/#examples","text":"# Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # Then, feed the resulting yaml into \"kubectl create\". # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko create -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # Then, feed the resulting yaml into \"kubectl create\". ko create --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # Then, feed the resulting yaml into \"kubectl create\". ko create --local -f config/ # Create from stdin: cat config.yaml | ko create -f - # Any flags passed after '--' are passed to 'kubectl apply' directly: ko apply -f config -- --namespace=foo --kubeconfig=cfg.yaml","title":"Examples"},{"location":"reference/ko_create/#options","text":"--as string Username to impersonate for the operation (DEPRECATED) --as-group stringArray Group to impersonate for the operation, this flag can be repeated to specify multiple groups. (DEPRECATED) --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --cache-dir string Default cache directory (DEPRECATED) --certificate-authority string Path to a cert file for the certificate authority (DEPRECATED) --client-certificate string Path to a client certificate file for TLS (DEPRECATED) --client-key string Path to a client key file for TLS (DEPRECATED) --cluster string The name of the kubeconfig cluster to use (DEPRECATED) --context string The name of the kubeconfig context to use (DEPRECATED) --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for create --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry --insecure-skip-tls-verify If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure (DEPRECATED) -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) --kubeconfig string Path to the kubeconfig file to use for CLI requests. (DEPRECATED) -L, --local Load into images to local docker daemon. -n, --namespace string If present, the namespace scope for this CLI request (DEPRECATED) --oci-layout-path string Path to save the OCI image layout of the built images --password string Password for basic authentication to the API server (DEPRECATED) --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --request-timeout string The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (DEPRECATED) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) -s, --server string The address and port of the Kubernetes API server (DEPRECATED) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs --tls-server-name string Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used (DEPRECATED) --token string Bearer token for authentication to the API server (DEPRECATED) --user string The name of the kubeconfig user to use (DEPRECATED) --username string Username for basic authentication to the API server (DEPRECATED)","title":"Options"},{"location":"reference/ko_create/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_create/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_delete/","text":"ko delete See \"kubectl help delete\" for detailed usage. ko delete [flags] Options -h, --help help for delete Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko delete"},{"location":"reference/ko_delete/#ko-delete","text":"See \"kubectl help delete\" for detailed usage. ko delete [flags]","title":"ko delete"},{"location":"reference/ko_delete/#options","text":"-h, --help help for delete","title":"Options"},{"location":"reference/ko_delete/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_delete/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_deps/","text":"ko deps Print Go module dependency information about the ko-built binary in the image Synopsis This sub-command finds and extracts the executable binary in the image, assuming it was built by ko, and prints information about the Go module dependencies of that executable, as reported by \"go version -m\". If the image was not built using ko, or if it was built without embedding dependency information, this command will fail. ko deps IMAGE [flags] Examples # Fetch and extract Go dependency information from an image: ko deps docker.io/my-user/my-image:v3 Options -h, --help help for deps --sbom string Format for SBOM output (supports: spdx, cyclonedx, go.version-m). (default \"spdx\") Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko deps"},{"location":"reference/ko_deps/#ko-deps","text":"Print Go module dependency information about the ko-built binary in the image","title":"ko deps"},{"location":"reference/ko_deps/#synopsis","text":"This sub-command finds and extracts the executable binary in the image, assuming it was built by ko, and prints information about the Go module dependencies of that executable, as reported by \"go version -m\". If the image was not built using ko, or if it was built without embedding dependency information, this command will fail. ko deps IMAGE [flags]","title":"Synopsis"},{"location":"reference/ko_deps/#examples","text":"# Fetch and extract Go dependency information from an image: ko deps docker.io/my-user/my-image:v3","title":"Examples"},{"location":"reference/ko_deps/#options","text":"-h, --help help for deps --sbom string Format for SBOM output (supports: spdx, cyclonedx, go.version-m). (default \"spdx\")","title":"Options"},{"location":"reference/ko_deps/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_deps/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_login/","text":"ko login Log in to a registry ko login [OPTIONS] [SERVER] [flags] Examples # Log in to reg.example.com ko login reg.example.com -u AzureDiamond -p hunter2 Options -h, --help help for login -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko login"},{"location":"reference/ko_login/#ko-login","text":"Log in to a registry ko login [OPTIONS] [SERVER] [flags]","title":"ko login"},{"location":"reference/ko_login/#examples","text":"# Log in to reg.example.com ko login reg.example.com -u AzureDiamond -p hunter2","title":"Examples"},{"location":"reference/ko_login/#options","text":"-h, --help help for login -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username","title":"Options"},{"location":"reference/ko_login/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_login/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_resolve/","text":"ko resolve Print the input files with image references resolved to built/pushed image digests. Synopsis This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and prints the resulting yaml. ko resolve -f FILENAME [flags] Examples # Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local and --preserve-import-paths were passed. ko resolve -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko resolve --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # This always preserves import paths. ko resolve --local -f config/ Options --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for resolve --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko resolve"},{"location":"reference/ko_resolve/#ko-resolve","text":"Print the input files with image references resolved to built/pushed image digests.","title":"ko resolve"},{"location":"reference/ko_resolve/#synopsis","text":"This sub-command finds import path references within the provided files, builds them into Go binaries, containerizes them, publishes them, and prints the resulting yaml. ko resolve -f FILENAME [flags]","title":"Synopsis"},{"location":"reference/ko_resolve/#examples","text":"# Build and publish import path references to a Docker # Registry as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local and --preserve-import-paths were passed. ko resolve -f config/ # Build and publish import path references to a Docker # Registry preserving import path names as: # ${KO_DOCKER_REPO}/<import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local was passed. ko resolve --preserve-import-paths -f config/ # Build and publish import path references to a Docker # daemon as: # ko.local/<import path> # This always preserves import paths. ko resolve --local -f config/","title":"Examples"},{"location":"reference/ko_resolve/#options","text":"--bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -f, --filename strings Filename, directory, or URL to files to use to create the resource -h, --help help for resolve --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) -R, --recursive Process the directory used in -f, --filename recursively. Useful when you want to manage related manifests organized within the same directory. --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") -l, --selector string Selector (label query) to filter on, supports '=', '==', and '!='.(e.g. -l key1=value1,key2=value2) --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs","title":"Options"},{"location":"reference/ko_resolve/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_resolve/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_run/","text":"ko run A variant of kubectl run that containerizes IMPORTPATH first. Synopsis This sub-command combines \"ko build\" and \"kubectl run\" to support containerizing and running Go binaries on Kubernetes in a single command. ko run IMPORTPATH [flags] Examples # Publish the image and run it on Kubernetes as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local and --preserve-import-paths were passed. ko run github.com/foo/bar/cmd/baz # This supports relative import paths as well. ko run ./cmd/baz # You can also supply args and flags to the command. ko run ./cmd/baz -- -v arg1 arg2 --yes Options --bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -h, --help help for run --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko run"},{"location":"reference/ko_run/#ko-run","text":"A variant of kubectl run that containerizes IMPORTPATH first.","title":"ko run"},{"location":"reference/ko_run/#synopsis","text":"This sub-command combines \"ko build\" and \"kubectl run\" to support containerizing and running Go binaries on Kubernetes in a single command. ko run IMPORTPATH [flags]","title":"Synopsis"},{"location":"reference/ko_run/#examples","text":"# Publish the image and run it on Kubernetes as: # ${KO_DOCKER_REPO}/<package name>-<hash of import path> # When KO_DOCKER_REPO is ko.local, it is the same as if # --local and --preserve-import-paths were passed. ko run github.com/foo/bar/cmd/baz # This supports relative import paths as well. ko run ./cmd/baz # You can also supply args and flags to the command. ko run ./cmd/baz -- -v arg1 arg2 --yes","title":"Examples"},{"location":"reference/ko_run/#options","text":"--bare Whether to just use KO_DOCKER_REPO without additional context (may not work properly with --tags). -B, --base-import-paths Whether to use the base path without MD5 hash after KO_DOCKER_REPO (may not work properly with --tags). --disable-optimizations Disable optimizations when building Go code. Useful when you want to interactively debug the created container. -h, --help help for run --image-label strings Which labels (key=value) to add to the image. --image-refs string Path to file where a list of the published image references will be written. --insecure-registry Whether to skip TLS verification on the registry -j, --jobs int The maximum number of concurrent builds (default GOMAXPROCS) -L, --local Load into images to local docker daemon. --oci-layout-path string Path to save the OCI image layout of the built images --platform strings Which platform to use when pulling a multi-platform base. Format: all | <os>[/<arch>[/<variant>]][,platform]* -P, --preserve-import-paths Whether to preserve the full import path after KO_DOCKER_REPO. --push Push images to KO_DOCKER_REPO (default true) --sbom string The SBOM media type to use (none will disable SBOM synthesis and upload, also supports: spdx, cyclonedx, go.version-m). (default \"spdx\") --tag-only Include tags but not digests in resolved image references. Useful when digests are not preserved when images are repopulated. -t, --tags strings Which tags to use for the produced image instead of the default 'latest' tag (may not work properly with --base-import-paths or --bare). (default [latest]) --tarball string File to save images tarballs","title":"Options"},{"location":"reference/ko_run/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_run/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"},{"location":"reference/ko_version/","text":"ko version Print ko version. ko version [flags] Options -h, --help help for version Options inherited from parent commands -v, --verbose Enable debug logs SEE ALSO ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"ko version"},{"location":"reference/ko_version/#ko-version","text":"Print ko version. ko version [flags]","title":"ko version"},{"location":"reference/ko_version/#options","text":"-h, --help help for version","title":"Options"},{"location":"reference/ko_version/#options-inherited-from-parent-commands","text":"-v, --verbose Enable debug logs","title":"Options inherited from parent commands"},{"location":"reference/ko_version/#see-also","text":"ko - Rapidly iterate with Go, Containers, and Kubernetes.","title":"SEE ALSO"}]}